A.txt
-----------------------------------------------------------
#include <stdio.h>
int main() {
    int n, m, i, j, k;
    n = 3; 
    m = 3; 
    int alloc[3][3] = { {0, 1, 0},
                        {2, 0, 0},
                        {3, 0, 2} };

    int max[3][3] = { {7, 5, 3},
                      {3, 2, 2},
                      {9, 0, 2} };

    int avail[3] = {3, 3, 2}; 
    int f[n], ans[n], ind = 0;
    for (k = 0; k < n; k++) {
        f[k] = 0;
    }
    int need[n][m];
    for (i = 0; i < n; i++) {
        for (j = 0; j < m; j++) {
            need[i][j] = max[i][j] - alloc[i][j];
        }
    }
    int y = 0;
    for (k = 0; k < n; k++) {
        for (i = 0; i < n; i++) {
            if (f[i] == 0) {
                int flag = 0;
                for (j = 0; j < m; j++) {
                    if (need[i][j] > avail[j]) {
                        flag = 1;
                        break;
                    }
                }
                if (flag == 0) {
                    ans[ind++] = i;
                    for (y = 0; y < m; y++) {
                        avail[y] += alloc[i][y];
                    }
                    f[i] = 1;
                }
            }
        }
    }
    int flag = 1;
    for (i = 0; i < n; i++) {
        if (f[i] == 0) {
            flag = 0;
            printf("The system is not safe\n");
            break;
        }
    }
    if (flag == 1) {
        printf("Safe Sequence is: ");
        for (i = 0; i < n - 1; i++) {
            printf("P%d -> ", ans[i]);
        }
        printf("P%d\n", ans[n - 1]);
    }
    return 0;
}


B_a.txt
-----------------------------------------------------------
#include <stdio.h>
#include <unistd.h>
#include <sys/wait.h>
void sort(int arr[], int n) {
    int i, j, temp;
    for(i=0; i<n-1; i++) {
        for(j=i+1; j<n; j++) {
            if(arr[i] > arr[j]) 
			{
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }
}

int main() {
    int arr[5], i;
    printf("Enter 5 numbers: ");
    for(i=0; i<5; i++) {
        scanf("%d", &arr[i]);
    }

    int pid = fork();

    if(pid == 0) { 
        printf("\nChild Process\n");
        sort(arr, 5);
        printf("Child sorted array: ");
        for(i=0; i<5; i++) {
            printf("%d ", arr[i]);
        }
        printf("\n");
    }
    else { 
        wait(NULL); 
        printf("\nParent Process\n");
        sort(arr, 5);
        printf("Parent sorted array: ");
        for(i=0; i<5; i++) {
            printf("%d ", arr[i]);
        }
        printf("\n");
    }
    return 0;
}

C.txt
-----------------------------------------------------------
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>

#define SIZE 5

int buffer[SIZE];
int count = 0; 

pthread_mutex_t mutex;
sem_t empty;
sem_t full;

void* producer(void* arg) {
    int item = 1;
    for(int i = 0; i < 5; i++) {
        sem_wait(&empty);          
        pthread_mutex_lock(&mutex); 
        buffer[count++] = item++;    
        printf("Producer produced item %d\n", buffer[count-1]);

        pthread_mutex_unlock(&mutex); 
        sem_post(&full);             
    }
    return NULL;
}

void* consumer(void* arg) {
    for(int i = 0; i < 5; i++) {
        sem_wait(&full);            
        pthread_mutex_lock(&mutex); 
        int item = buffer[--count]; 
        printf("Consumer consumed item %d\n", item);

        pthread_mutex_unlock(&mutex); 
        sem_post(&empty);              
    }
    return NULL;
}

int main() {
    pthread_t prod, cons;

    pthread_mutex_init(&mutex, NULL);
    sem_init(&empty, 0, SIZE); 
    sem_init(&full, 0, 0);     

    pthread_create(&prod, NULL, producer, NULL);
    pthread_create(&cons, NULL, consumer, NULL);

    pthread_join(prod, NULL);
    pthread_join(cons, NULL);

    pthread_mutex_destroy(&mutex);
    sem_destroy(&empty);
    sem_destroy(&full);

    return 0;
}

D.txt
-----------------------------------------------------------
#include <stdio.h>

struct Process {
    int id;
    int arrival;
    int burst;
    int remaining;
    int finish;
};

void SJF_Preemptive(struct Process p[], int n) {
    int time = 0, completed = 0, shortest = -1;
    printf("\n--- SJF (Preemptive) ---\n");

    while (completed != n) {
        int min = 9999;
        shortest = -1;

        for (int i = 0; i < n; i++) {
            if (p[i].arrival <= time && p[i].remaining > 0 && p[i].remaining < min) {
                min = p[i].remaining;
                shortest = i;
            }
        }

        if (shortest == -1) {
            time++;
            continue;
        }

        p[shortest].remaining--;
        time++;

        if (p[shortest].remaining == 0) {
            completed++;
            p[shortest].finish = time;
        }
    }

    printf("\nProcess\tArrival\tBurst\tFinish\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t%d\t%d\t%d\n", p[i].id, p[i].arrival, p[i].burst, p[i].finish);
    }
}

void RoundRobin(struct Process p[], int n, int quantum) {
    int time = 0;
    int done;

    printf("\n--- Round Robin ---\n");

    while (1) {
        done = 1;
        for (int i = 0; i < n; i++) {
            if (p[i].remaining > 0 && p[i].arrival <= time) {
                done = 0;
                if (p[i].remaining > quantum) {
                    time += quantum;
                    p[i].remaining -= quantum;
                } else {
                    time += p[i].remaining;
                    p[i].remaining = 0;
                    p[i].finish = time;
                }
            }
        }
        if (done)
            break;
    }

    printf("\nProcess\tArrival\tBurst\tFinish\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t%d\t%d\t%d\n", p[i].id, p[i].arrival, p[i].burst, p[i].finish);
    }
}

int main() {
    int n, quantum;
    printf("Enter number of processes: ");
    scanf("%d", &n);

    struct Process p1[n], p2[n];

    for (int i = 0; i < n; i++) {
        printf("Enter Arrival and Burst Time for Process %d: ", i + 1);
        scanf("%d%d", &p1[i].arrival, &p1[i].burst);
        p1[i].id = i + 1;
        p1[i].remaining = p1[i].burst;
    }

    for (int i = 0; i < n; i++) {
        p2[i] = p1[i];
    }

    printf("Enter time quantum for Round Robin: ");
    scanf("%d", &quantum);

    SJF_Preemptive(p1, n);
    RoundRobin(p2, n, quantum);

    return 0;
}

E.txt
-----------------------------------------------------------
#include <stdio.h>
#include <pthread.h>
#include <semaphore.h>

#define SIZE 5

int buffer[SIZE];
int count = 0; 

pthread_mutex_t mutex;
sem_t empty;
sem_t full;

void* producer(void* arg) {
    int item = 1;
    for(int i = 0; i < 5; i++) {
        sem_wait(&empty);          
        pthread_mutex_lock(&mutex); 
        buffer[count++] = item++;    
        printf("Producer produced item %d\n", buffer[count-1]);

        pthread_mutex_unlock(&mutex); 
        sem_post(&full);             
    }
    return NULL;
}

void* consumer(void* arg) {
    for(int i = 0; i < 5; i++) {
        sem_wait(&full);            
        pthread_mutex_lock(&mutex); 
        int item = buffer[--count]; 
        printf("Consumer consumed item %d\n", item);

        pthread_mutex_unlock(&mutex); 
        sem_post(&empty);              
    }
    return NULL;
}

int main() {
    pthread_t prod, cons;

    pthread_mutex_init(&mutex, NULL);
    sem_init(&empty, 0, SIZE); 
    sem_init(&full, 0, 0);     

    pthread_create(&prod, NULL, producer, NULL);
    pthread_create(&cons, NULL, consumer, NULL);

    pthread_join(prod, NULL);
    pthread_join(cons, NULL);

    pthread_mutex_destroy(&mutex);
    sem_destroy(&empty);
    sem_destroy(&full);

    return 0;
}

F.txt
-----------------------------------------------------------
#include <stdio.h>

#define MAX 20

void FCFS(int pages[], int n, int frames) {
    int frame[frames], i, j, k = 0, faults = 0, found;
    for (i = 0; i < frames; i++) frame[i] = -1;

    printf("\n--- FCFS Page Replacement ---\n");

    for (i = 0; i < n; i++) {
        found = 0;
        for (j = 0; j < frames; j++) {
            if (frame[j] == pages[i]) {
                found = 1;
                break;
            }
        }
        if (!found) {
            frame[k] = pages[i];
            k = (k + 1) % frames;
            faults++;
        }

        printf("Frames: ");
        for (j = 0; j < frames; j++) {
            if (frame[j] != -1) printf("%d ", frame[j]);
            else printf("- ");
        }
        printf("\n");
    }

    printf("Total Page Faults = %d\n", faults);
}

void LRU(int pages[], int n, int frames) {
    int frame[frames], time[frames], i, j, k, faults = 0, found, least;

    for (i = 0; i < frames; i++) frame[i] = -1;

    printf("\n--- LRU Page Replacement ---\n");

    for (i = 0; i < n; i++) {
        found = 0;
        for (j = 0; j < frames; j++) {
            if (frame[j] == pages[i]) {
                found = 1;
                time[j] = i;
                break;
            }
        }
        if (!found) {
            int min = 9999;
            for (j = 0; j < frames; j++) {
                if (time[j] < min) {
                    min = time[j];
                    least = j;
                }
            }
            frame[least] = pages[i];
            time[least] = i;
            faults++;
        }

        printf("Frames: ");
        for (j = 0; j < frames; j++) {
            if (frame[j] != -1) printf("%d ", frame[j]);
            else printf("- ");
        }
        printf("\n");
    }

    printf("Total Page Faults = %d\n", faults);
}

void Optimal(int pages[], int n, int frames) {
    int frame[frames], i, j, k, faults = 0, found, farthest, idx;

    for (i = 0; i < frames; i++) frame[i] = -1;

    printf("\n--- Optimal Page Replacement ---\n");

    for (i = 0; i < n; i++) {
        found = 0;
        for (j = 0; j < frames; j++) {
            if (frame[j] == pages[i]) {
                found = 1;
                break;
            }
        }
        if (!found) {
            if (i < frames) {
                frame[i] = pages[i];
            } else {
                farthest = -1;
                idx = -1;
                for (j = 0; j < frames; j++) {
                    int next_use = -1;
                    for (k = i + 1; k < n; k++) {
                        if (pages[k] == frame[j]) {
                            next_use = k;
                            break;
                        }
                    }
                    if (next_use == -1) {
                        idx = j;
                        break;
                    } else if (next_use > farthest) {
                        farthest = next_use;
                        idx = j;
                    }
                }
                frame[idx] = pages[i];
            }
            faults++;
        }

        printf("Frames: ");
        for (j = 0; j < frames; j++) {
            if (frame[j] != -1) printf("%d ", frame[j]);
            else printf("- ");
        }
        printf("\n");
    }

    printf("Total Page Faults = %d\n", faults);
}

int main() {
    int pages[MAX], n, frames, i;

    printf("Enter number of pages: ");
    scanf("%d", &n);

    printf("Enter page reference string:\n");
    for (i = 0; i < n; i++) {
        scanf("%d", &pages[i]);
    }

    printf("Enter number of frames (minimum 3): ");
    scanf("%d", &frames);

    if (frames < 3) {
        printf("Frame size should be at least 3!\n");
        return 1;
    }

    FCFS(pages, n, frames);
    LRU(pages, n, frames);
    Optimal(pages, n, frames);

    return 0;
}

G.txt
-----------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <unistd.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>

#define FIFO1 "fifo1"
#define FIFO2 "fifo2"

int main() {
    int fd1, fd2;
    char buffer[100];
    pid_t pid;

    // Create FIFOs
    mkfifo(FIFO1, 0666);
    mkfifo(FIFO2, 0666);

    pid = fork();

    if (pid > 0) { // Parent Process
        printf("Enter a sentence:\n");
        fgets(buffer, sizeof(buffer), stdin);

        fd1 = open(FIFO1, O_WRONLY);
        write(fd1, buffer, strlen(buffer) + 1);
        close(fd1);

        fd2 = open(FIFO2, O_RDONLY);
        read(fd2, buffer, sizeof(buffer));
        printf("\nResult from child:\n%s\n", buffer);
        close(fd2);

        unlink(FIFO1);
        unlink(FIFO2);
    }
    else { 
        int chars = 0, words = 0, lines = 0;
        FILE *file;

        fd1 = open(FIFO1, O_RDONLY);
        read(fd1, buffer, sizeof(buffer));
        close(fd1);

        for (int i = 0; buffer[i] != '\0'; i++) {
            chars++;
            if (buffer[i] == ' ' || buffer[i] == '\n') words++;
            if (buffer[i] == '\n') lines++;
        }
        words++;
        if (lines == 0) lines = 1;

        file = fopen("output.txt", "w");
        fprintf(file, "Characters: %d\nWords: %d\nLines: %d\n", chars, words, lines);
        fclose(file);

        file = fopen("output.txt", "r");
        fread(buffer, sizeof(char), 100, file);
        fclose(file);

        fd2 = open(FIFO2, O_WRONLY);
        write(fd2, buffer, strlen(buffer) + 1);
        close(fd2);

        exit(0);
    }

    return 0;
}


H.txt
-----------------------------------------------------------
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n, head, i, j, total = 0;
    int req[100], temp, disk_size;

    printf("Enter number of requests: ");
    scanf("%d", &n);

    printf("Enter request sequence:\n");
    for(i = 0; i < n; i++)
        scanf("%d", &req[i]);

    printf("Enter initial head position: ");
    scanf("%d", &head);

    printf("Enter disk size: ");
    scanf("%d", &disk_size);

    // ========== SSTF ==========
    int done[100] = {0}, pos = head;
    printf("\n--- SSTF ---\n");
    total = 0;
    for(i = 0; i < n; i++) {
        int min = 10000, index = -1;
        for(j = 0; j < n; j++) {
            if(!done[j] && abs(pos - req[j]) < min) {
                min = abs(pos - req[j]);
                index = j;
            }
        }
        done[index] = 1;
        total += abs(pos - req[index]);
        printf("Move to %d\n", req[index]);
        pos = req[index];
    }
    printf("Total Seek Time (SSTF): %d\n", total);

    // ========== SCAN ==========
    printf("\n--- SCAN ---\n");
    total = 0;
    int arr[100];
    for(i = 0; i < n; i++) arr[i] = req[i];
    arr[n++] = disk_size - 1; // Add end of disk

    // Sort
    for(i = 0; i < n-1; i++) {
        for(j = i+1; j < n; j++) {
            if(arr[i] > arr[j]) {
                temp = arr[i];
                arr[i] = arr[j];
                arr[j] = temp;
            }
        }
    }

    pos = head;
    int idx;
    for(i = 0; i < n; i++) {
        if(arr[i] >= head) {
            idx = i;
            break;
        }
    }

    for(i = idx; i < n; i++) {
        printf("Move to %d\n", arr[i]);
        total += abs(pos - arr[i]);
        pos = arr[i];
    }
    for(i = idx-1; i >= 0; i--) {
        printf("Move to %d\n", arr[i]);
        total += abs(pos - arr[i]);
        pos = arr[i];
    }
    printf("Total Seek Time (SCAN): %d\n", total);

    // ========== C-LOOK ==========
    printf("\n--- C-LOOK ---\n");
    total = 0;
    n--; // remove the extra disk_size - 1 added for SCAN
    for(i = 0; i < n-1; i++) {
        for(j = i+1; j < n; j++) {
            if(req[i] > req[j]) {
                temp = req[i];
                req[i] = req[j];
                req[j] = temp;
            }
        }
    }

    pos = head;
    for(i = 0; i < n; i++) {
        if(req[i] >= head) {
            idx = i;
            break;
        }
    }

    for(i = idx; i < n; i++) {
        printf("Move to %d\n", req[i]);
        total += abs(pos - req[i]);
        pos = req[i];
    }
    if(idx > 0) {
        total += abs(pos - req[0]);
        pos = req[0];
        printf("Jump to %d\n", pos);

        for(i = 0; i < idx; i++) {
            printf("Move to %d\n", req[i]);
            total += abs(pos - req[i]);
            pos = req[i];
        }
    }
    printf("Total Seek Time (C-LOOK): %d\n", total);

    return 0;
}


-----------------------------------------------------------
1. echo
   - The echo command is used to display text or variables to the terminal.
   Example:
   echo "Hello, World!"
   Output: Hello, World!

2. ls
   - The ls command lists the files and directories in the current directory.
   Example:
   ls
   Output: file1.txt  file2.txt

3. read
   - The read command accepts input from the user in a script.
   Example:
   echo "Enter your name:"
   read name
   echo "Hello, $name"
   
4. cat
   - The cat command is used to display the contents of a file.
   Example:
   cat file.txt
   Output: Content of file.txt

5. touch
   - The touch command creates an empty file or updates the timestamp of an existing file.
   Example:
   touch newfile.txt
   Output: Creates newfile.txt

6. test
   - The test command evaluates expressions like file properties, string comparisons, etc.
   Example:
   test -f file.txt && echo "File exists" || echo "File does not exist"
   Output: File exists

7. Loops:
   - for loop: Repeats a set of commands for a specific number of iterations.
     Example:
     for i in {1..5}; do echo "Iteration $i"; done
     
   - while loop: Runs as long as a specified condition is true.
     Example:
     i=1; while [ $i -le 5 ]; do echo "Iteration $i"; ((i++)); done

8. Arithmetic
   - Use $(( )) for basic arithmetic operations.
   Example:
   a=5; b=3; sum=$((a + b)); echo $sum
   Output: 8

9. Comparison
   - Numeric comparisons: -eq, -ne, -gt, -lt, -ge, -le.
   Example:
   if [ $a -gt $b ]; then echo "$a is greater than $b"; fi
   Output: 5 is greater than 3

   - String comparisons: =, !=.
   Example:
   if [ "$string1" = "$string2" ]; then echo "Strings are equal"; else echo "Strings are not equal"; fi

10. Conditional Statements (if, else, elif)
    - Execute commands based on conditions.
    Example:
    if [ -f file.txt ]; then echo "File exists"; else echo "File does not exist"; fi

11. grep
    - The grep command searches for patterns in files.
    Example:
    grep "error" log.txt
    Output: Lines with "error" in log.txt

12. sed
    - The sed command is used for text manipulation like replacing or deleting text in files.
    Example:
    sed 's/hello/hi/' file.txt
    Output: Replaces "hello" with "hi" in file.txt
